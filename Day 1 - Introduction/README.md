# Day 1 - Introduction

## WHAT IS HEAP?
Bài đầu tiên, chúng ta sẽ tìm hiểu Heap là gì.

Một chương trình C điển hình có cấu trúc bộ nhớ bao gồm 5 phần:
1. **Text segment**: chứa code thực thi của chương trình.
2. **Data segment**: chứa các biến global và biến static đã được khởi tạo giá trị bởi người dùng.
3. **BSS segment**: chứa các biến global và biến static không được khởi tạo giá trị một cách tường minh.
4. **Heap**: chứa dữ liệu được cấp phát động bởi người dùng.
5. **Stack**: được cấu trúc thành từng frame, mỗi frame là vùng nhớ riêng của một hàm, được sắp xếp theo thứ tự lời gọi hàm. 

![memoryLayoutC.jpg](memoryLayoutC.jpg)

Bộ nhớ Heap phát triển theo hướng từ địa chỉ thấp đến địa chỉ cao (ngược lại vào Stack), được cấu tạo thành các đơn vị bộ nhớ gọi là chunk với kích thước tùy thuộc vào người dùng yêu cầu. Mỗi khi người dùng gọi hàm `malloc()` (hay các hàm tương tự như calloc(), realloc(), ...), bộ nhớ sẽ cấp phát 1 vùng nhớ với kích thước phù hợp. Khi không dùng đến nữa, người dùng sẽ giải phóng vùng nhớ đó thông qua hàm `free` để có thể sử dụng lại vùng nhớ đó sau này (nhằm tiết kiệm bộ nhớ).


## HEAP RULES
Heap giúp cho việc sử dụng bộ nhớ hiệu quả hơn, tuy nhiên để sử dụng nó một cách hiệu quả và an toàn người dùng cần tuân thủ các nguyên tắc sau:
1. Không đọc hoặc ghi vào một chunk nhớ đã `freed`.
	Nếu không sẽ đẫn đến lỗi **user after free**.
2. Không sử dụng hoặc leak thông tin chưa được khởi tạo trong một chunk.
	Nếu không sẽ đẫn đến lỗi **information leaks** hoặc **uninitialized data**.
3. Không đọc hoặc ghi vào các bytes nằm sau một chunk.
	Nếu không sẽ đẫn đến lỗi **heap overflow** hoặc **read beyond bounds**.
4. Không `free()` một chunk 2 lần.
	Nếu không sẽ đẫn đến lỗi **double free**.
5. Không đọc hoặc ghi vào các bytes nằm trước một chunk.
	Nếu không sẽ đẫn đến lỗi **heap underflow**.
6. Không `free()` một con trỏ chưa được khởi tạo bởi hàm `malloc()`.
	Nếu không sẽ đẫn đến lỗi **invalid free**.
7. Không sử dụng một con trỏ được khởi tạo bởi hàm `malloc()` nếu return value của `malloc` là NULL.
	Nếu không sẽ đẫn đến lỗi **arbitrary write**.



## CHUNK ALLOCATION STRATEGIES
Mỗi khi người dùng yêu cầu cấp phát (allocate) một vùng nhớ. Bộ nhớ sẽ theo chiến lược sau:
1. Nếu có một chunk nhớ đã free trước đó, và kích thước của nó đủ lớn so với yêu cầu của người dùng. Bộ nhớ sẽ cấp phát vùng nhớ đó.
2. Ngược lại, nếu có một vùng nhớ đủ lớn ở đỉnh của heap, bộ nhớ sẽ cấp phát vùng nhớ đó.
3. Ngược lại, bộ nhớ sẽ yêu cầu kernel cấp thêm vùng nhớ mới với đỉnh của heap và sử dụng nó cấp phát cho người dùng.
4. Nếu tất cả các chiến lược trên đều fail, bộ nhớ không thể allocate, `malloc()` sẽ return NULL.

#### ALLOCATING FROM FREE'D CHUNKS.
Các chunk đã được free sẽ được đưa vào các **bin**. **Bin** là danh sách dùng để truy dấu các chunks đã free. Có nhiều loại **bin**, Mỗi loại gồm nhiều **bin**. Mỗi **bin** được cấu trúc dưới dạng **singly linked list** hoặc **doubly linked list**. Mỗi node của **bin** là một chunk, có chứa con trỏ **FD** và **BK** để trỏ tới các chunk kế bên trong **bin**.

![bins-simple.png](bins-simple.png)

#### ALLOCATING FROM THE TOP OF THE HEAP.
Chunk nằm ở đỉnh heap được gọi là **top chunk** hoặc **remainder chunk**. Nếu không có chunk nào trong bin có thể allocate, bộ nhớ sẽ cấp phát vùng nhớ mới từ top chunk.

![heap-chunks-top.gif](heap-chunks-top.gif)

#### OFF-HEAP ALLOCATIONS VIA MMAP.
Nếu người dùng yêu cầu cấp phát một vùng nhớ quá lớn (>= 128KB-512KB trên 32bit-OS hoặc 32MB trên 64bit-OS). Chunk này sẽ được cấp phát off-heap thông qua lời gọi trực tiếp đến `mmap`. Khi chunk này được `freed`, nó sẽ được giải phóng trả về cho OS thông qua hàm `munmap`.

#### ARENA AND SUBHEAP.
Đối với các ứng dụng multithread, bộ nhớ cần phải tránh xảy ra lỗi race condition. Nó sử dụng khái niệm areana. Mỗi thread có một arena riêng. Mỗi arena là một vùng nhớ heap riêng biệt có các chunk được allocated và các free bins riêng.

Main arena là arena của main thread, và nó là arena duy nhất nếu đó là ứng dụng single-thread. Secondary arena là các arena thuộc về subheaps. Các secondary arenas nằm phía sau main arena trong heap.

![heap-arenas-CS.png](heap-arenas-CS.png)


## CHUNK STRUCTURE
Một chunk có 2 trạng thái: `allocated` và `freed`, tùy vào trạng thái của chunk mà cấu trúc chunk sẽ khác nhau. Mỗi chunk dù là `allocated` hay `freed` đều có vùng `metadata` để chứa thông tin về chunk đó. Bộ nhớ luôn cấp phát một chunk với kích thước là bội số của 8 (đối với 32 bit) hoặc 16 (đối với 64 bit). Các chunk `allocated` và `freed` nằm đan xen nhau trong heap segment. Do đó cần có cơ chế để biết được đầu là `allocated chunk`, đâu là `freed chunk`.

#### ALLOCATED CHUNK
Metadata của một `allocated chunk` có kích thước 8 bytes (đối với hệ thống 32 bit) hoặc 16 bytes (đối với hệ thống 64 bit) bao gồm:
1. **prev_size**: Tuy nằm trong vùng metadata của chunk này nhưng thật ra lại chứa thông tin của chunk trước đó. Nếu chunk trước đó là `freed chunk`, nó sẽ chứa kích thước của chunk trước (tính luôn phần metadata). Nếu chunk trước đó là `allocated chunk`, bộ nhớ heap tận dụng nó để lưu trữ user data.
2. **chunk size**: kích thước của chunk hiện tại. Vì kích thước của chunk là bội số của 8 hoặc 16 nên 3 bit cuối của **chunk size** luôn là 0. Bộ nhớ tận dụng 3 bit này được ký hiệu là (A,M,P) để lưu trạng thái của chunk.
	- A (0x04): **Allocated area**, được set là 1 nếu chunk có nguồn gốc từ secondary arena, được set là 0 nếu chunk có nguồn gốc từ main arena. Bộ nhớ dùng bit này để biết nguồn gốc của chunk mà return con trỏ về cho main thread hay subthread.
	- M (0x02): **Mmap'd chunk**: được set là 1 nếu chunk được cấp phát off-heap qua `mmap`. Khi chunk được `freed`, Heap manager sẽ giải phóng bộ nhớ trả về cho OS qua `munmap` chứ không đưa nó vào bin để tái sử dụng.
	- P (0x01): **Previous chunk in use**: mang thông tin về chunk trước đó. Được set là 1 nếu chunk trước đó là `freed chunk`, là 0 nếu chunk trước đó là `allocated chunk`. Nhờ đó, khi chunk được `freed`, nó có thể biết được chunk trước đó là `freed chunk` và gộp 2 chunk lại thành một `freed chunk` lớn hơn.

Phần còn lại của chunk là **User Data**: chứa dữ liệu của chunk.

![chunk-allocated-CS.png](chunk-allocated-CS.png)

#### FREED CHUNK
Metadata của `freed chunk` cấu trúc tương tự `allocated chunk`, gồm 2 phần **prev_size** và **chunk size**. Sau khi 1 chunk được `freed`, nó sẽ được đưa vào **bin**. Các bins hoạt động theo cấu trúc **linked list**, do đó nó cần có cách nào đó để truy dấu các chunk nằm kế bên trong cùng 1 bin. Khi chunk được `freed`, vùng user data trở nên vô dụng. Bộ nhớ tận dùng vùng này để chứa 2 con trỏ **FD_Pointer** và **BK_Pointer** trỏ tới 2 chunk nằm trước và sau trong cùng 1 bin. Nhờ đó, khi người dùng yêu cầu cấp phát một vùng nhớ, bộ nhớ sẽ đi tìm nó trong các bins một cách dễ dàng.

![chunk-freed-CS.png](chunk-freed-CS.png)


## BINS 
Bin là một khái niệm của glibc để truy dấu các freed-chunk dưới dạng **linked list**. Nó tồn tại nhờ vào các con trỏ **FD_Pointer** và **BK_Pointer** của freeed-chunk, chứ nó không thật sự tốn thêm dung lượng bộ nhớ của chương trình. Mỗi khi chunk được freed, nó sẽ được đưa vào bin có kích thước tương ứng, để lần sau nếu người dùng yêu cầu cấp phát một chunk mới với kích thước tương tự, bộ nhớ sẽ lấy chunk ra khỏi bin và cấp phát ngay cho người dùng, thay vì phải tạo chunk mới từ top heap, giúp cải thiện hiệu năng của heap.

Để quá trình tái sử dụng các chunk được hiệu quả, bộ nhớ heap sử dụng nhiều loại bins khác nhau. Mỗi loại bao gồm nhiều bin. Mỗi bin là một list các freed chunk cùng kích thước hoặc kích thước gần bằng nhau (tùy vào loại bin). Có 5 loại bin trong glibc 2.27:

1. 62 **small bins**: dưới dạng *doubly linked list*. Mỗi bin lưu trữ các `freed chunk` có cùng kích thước, bao phủ kích thước chunk từ 0x10 bytes đến < 0x200 bytes (32 bit) hoặc < 0x400 bytes (64-bit).
2. 63 **large bins**: dưới dạng *doubly linked list*. Mỗi **large bin** lưu trữ các `freed chunk` không cùng kích thước, bao phủ kích thước chunk >= 200 bytes (32 bit) hoặc >= 0x400 bytes (64 bit).
3. 1 **unsorted bin**: dưới dạng *doubly linked list*. Đây là một bin trung gian, chứa các chunk vừa mới được `freed`, và sẽ được trả lại vào các `small bins` hay `large bins` sau này. Điều này là nhằm cải thiện hiệu năng của heap. **Unsorted bin** chứa các chunk không cùng một kích thước, không giống như `small bin` và `large bin`.
4. 10 **fast bins**: dưới dạng *singly linked list*. Đây cũng là một dạng bin trung gian giúp cải thiện hiệu năng heap. **Fast bin** chứa các chunk cùng kích thước, và kích thước của **fast bin** là nhỏ, bao phủ kích thước 0x10 - 0x58 bytes (32 bit) hoặc 0x10 - 0x100 bytes (64 bit).
5. 64 **tcache bins** cho mỗi thread: dưới dạng *singly linked list*. Mỗi bin chứa tối đa 7 chunks cùng kích thước.**Tcache bin** là một loại bin mới được thêm vào kể từ glibc 2.26, nhằm cải thiện hiệu năng đối với các ứng dụng multi-threads. 

#### SMALL BINS
![bins-small.png](bins-small.png)

Small bins là loại bin đơn giản nhât. Có 62 small bins, mỗi bin chứa các chunk cùng kích thước. Dãy kích thước của các small bins lần luợt là: 0x10, 0x18, 0x20, ..., 0x1f8 (32 bit) hoặc 0x20, 0x30, 0x40, ..., 0x3f0 (64 bit). Small bins được lưu trữ dưới dạng doubly linked list, hoạt động theo kiểu FIFO (first in - first out).

#### LARGE BINS
![bins-large.png](bins-large.png)

Large bins là một loại bin cơ bản, tương tự như small bins. Có 63 large bins, mỗi bin chứa các chunk nằm trong một dãy kích thước cụ thể. Vì các ứng dụng có xu hướng sử dụng các vùng nhớ có kích thước nhỏ nên các large bin co cụm về phía kích thước nhỏ, nghĩa là các large bin càng nhỏ thì bao phủ dãy kích thước càng nhỏ.

Đối với 32 bit OS, 32 large bins đầu tiên chứa các chunk nằm trong dãy kích thước cách nhau 0x40 bytes:
- large bin 1: 0x200 - 0x238
- large bin 2: 0x240 - 0x278
- ...

16 bins tiếp theo mỗi bin cách nhau 0x200 bytes, 8 bins tiếp theo cách nhau 0x1000 bytes, 4 bins tiếp theo cách nhau 0x8000 bytes, 2 bins tiếp theo cách nhau 0x40000 bytes, và 1 bin cuối cùng chứa các kích thước lớn còn lại.

Large bins được lưu trữ dưới dạng doubly linked list, hoạt động theo kiểu FIFO tương tự small bins.

Các bin của small bins và large bins được cấu tạo để không chồng lấp lên nhau. Với một kích thước chunk cho trước, ta luôn tìm được duy nhất 1 bin tương ứng với nó trong small bins hoặc large bins.

#### UNSORTED BIN
![bins-unsorted.png](bins-unsorted.png)

Với small bins và large bins, đã đủ để lưu trữ tất cả các chunk được freed. Vậy sao lại cần unsorted bin nữa? Unsorted bin là một tính năng giúp cải tiến hiệu suất, dựa trên quan sát rằng, trong một chương trình, thường thì ngay sau khi `free()` một con trỏ, người dùng sẽ yêu cầu `malloc()` một con trỏ khác có cùng kích thước hoặc kích thước tương tự.

Do đó, thay vì ngay lập tức đẩy chunk vừa được `freed` vào small bin hay large bin tương ứng, bộ nhớ sẽ gộp nó với các `freed chunk` xung quanh (ngay trước và ngay sau trong memory) thành một chunk lớn hơn, và đẩy nó vào unsorted bin. Sau đó, khi người dùng yêu cầu cấp phát vùng nhớ mới, bộ nhớ sẽ lặp qua từng chunk trong unsorted bin tìm xem có chunk nào phù hợp. Nếu chunk phù hợp, nó sẽ được cấp phát cho người dùng, còn nếu không chunk đó sẽ được trả về small bin hay large bin tương ứng.

Unsorted bin cũng được lưu trữ dưới dạng doubly linked list.

#### FAST BINS
![bins-fast.png](bins-fast.png)

Fast bin là một tính năng khác giúp cải thiện hiệu suất của heap. Fast bin lưu giữ những chunk nhỏ được `freed` gần đây vào một list, và các chunk này sẽ không bao giờ được gộp với các `freed chunk` xung quanh, nhằm mục đích cung cấp ngay cho người dùng một chunk nhỏ có kích thước phù hợp. Để bảo đảm các chunk trong fast bin không bị gộp, bộ nhớ sẽ không thực sự `free` nó, bằng cách vẫn set bit **P** (prev_in_use) của chunk kế tiếp là 1. 

Có 10 fast bin, mỗi bin lưu trữ các chunk cùng kích thước. Đối với 32bit OS, dãy fast bin thay đổi từ: 0x10, 0x18, 0x20, ..., 0x60. Đối với 64 bit OS, dãy kích thước bin là: 0x20, 0x30, ..., 0xb0.

Các chunk trong fast bins không bao giờ được gộp với chunk xung quanh, nên nó có thể được lưu trữ dưới dạng singly linked list. Không giống như small chunk và large chunk khi được gộp, nó cần phải được remove ra khỏi bin list tương ứng, do đó cần có cơ chế doubly linked list để remove một node bất kỳ trong linked list.

Tuy nhiên, bất lợi của fast bins là nó không được gộp lại, nên sẽ dẫn đến hiện tượng phân mảnh bộ nhớ. Để giải quyết vấn đề này, bộ nhớ sẽ định kỳ dọn dẹp, hay `consolidated` heap, bằng cách tiến hành gộp các chunk trong fast bin với chunk xung quanh, và đặt nó vào unsorted bin.

Quá trình `consolidation` này xảy ra bất cứ khi nào người dùng yêu cầu cấp phát một vùng nhớ lớn hơn khả năng của fast bin, hay khi `free` một chunk > 64KB, hoặc khi các hàm `malloc_trim` hoặc `malloc_opt` được gọi.

#### TCACHE BINS
Tcache bins là một cải tiến nữa mới được bổ sung kể từ phiên bản glibc 2.26. Nhằm phục vụ cho các ứng dụng multi-threads. Đối với ứng dụng multi-threads, các threads sẽ chia sẽ chung một số tài nguyên như: Code segment, heap, ... tuy nhiên mỗi thread sẽ có riêng một bộ registers và stack.

![bins-fast.png](bins-fast.png)

Vùng heap là tại nguyên chia sẽ chung, vì thế khi nhiều thread cùng hoạt động trên heap sẽ dễ dẫn đến race condition. Trước phiên bản glibc 2.26, vấn đề được giải quyết bằng cơ chế `lock contention`: khi một thread hoạt động trên heap, nó sẽ giữ `lock`, các thread khác không thể làm gì trên heap mà phải đợi đến khi thread kia xong việc, thì thread tiếp theo mới được giữ `lock`. Nhưng như vậy lại làm cho hiệu suất của ứng dụng trở nên kém.

Kể từ glibc 2.26, cơ chế tcache bins giúp cải thiện hiệu suất. Mỗi thread có 64 tcache bins, được lưu trữ dưới dạng singly-linked list. Mỗi bin chứa tối đa 7 chunk cùng kích thước thay đổi từ 0xc -> 0x204 bytes (32 bit OS) hoặc 0x18 -> 0x408 bytes (64 bit OS).

Khi một chunk được `freed`, heap manager sẽ xem nếu kích thước chunk phù hợp với tcache bins, nó sẽ được đẩy vào tcache bin tương ứng. Cũng giống như Fast bin, Tcache bin sẽ không được gộp với chunk xung quanh, nhờ vào việc set bit **P** của chunk kế tiếp thành 1.

Nếu tcache bin của bin tương ứng đã đầy (7 chunks), heap manager sẽ trở về chiến lược trước đó bằng cách chờ lấy `heap lock`, và thực hiện `free` giống như phía trên.

Trong trường hợp, khi người dùng yêu cầu cấp phát một chunk với kích thước phù hợp tcache bin, nhưng bin này lại trống, thì thread cũng sẽ chờ để lấy `heap lock`, tuy nhiên lúc này khi đã có được `heap lock`, nó sẽ tranh thủ 'vơ vét' các chunk khác cùng kích thước nằm trong small bin, fast bin và đẩy vào tcache bin của mình, rồi trả về một chunk cho người dùng.


## ALLOCATION AND FREE STRATEGIES
Tổng hợp lại kiến thức từ đầu tới giờ, ta sẽ liệt kê các bước trong chiến lược allocation và free của heap manager.

#### ALLOCATION STRATEGIES:
Mỗi khi người dùng yêu cầu cấp phát một vung nhớ, heap manager của thread sẽ tiến hành theo các bước:

1. Nếu kích thước yêu cầu tương tứng với tcache bin, và có một tcache chunk sẵn sàng trong bin, ngay lập tức cấp phát nó cho người dùng.
2. Nếu kích thước yêu cầu quá lớn, sử dụng cở chế cấp phát off-heap qua `mmap`.
3. Ngược lại, chờ để lấy `heap lock`. Khi có được `heap lock` sẽ:
	1. Thử chiến lược tại sử dụng fast bin/ small bin:
		- Nếu có một fast bin tương tứng, cấp phát một chunk từ fast bin đó (đồng thời tranh thủ `vơ vét` các chunk này về điền đầy tcache bin tương ứng).
		- Ngược lại, nếu có một small bin tương ứng, cấp phát một chunk từ small bin đó (đồng thời tranh thủ `vơ vét` các chunk này về điền đầy tcache bin tương ứng).
	2. Nếu chiến lược trên thất bại, tiến hành dọn dẹp (`consolidation`) bộ nhớ bằng cách:
		- Thật sự `free` các chunk trong fast-bins và đẩy các chunk đã được gộp vào unsorted bin.
		- Sau đó lặp qua từng chunk trong unsorted bin. Nếu nó phù hợp, cấp phát nó và return (đồng thời tranh thủ `vơ vét` các chunk này về điền đầy tcache bin tương ứng). Nếu chunk nào không phù hợp, trả nó về small bin hoặc large bin tương ứng.
	3. Nếu vẫn không tìm được chunk phù hợp, tiến hành chiến lược tái sử dụng cơ bản:
		- Tìm trong large bin, nếu có chunk phù hợp thì cấp phát cho người dùng.
	4. Nếu các chiên lược vẫn không thành công, tạo một chunk mới từ top heap:
		- Thử tạo một chunk mới từ top heap và return cho người dùng.
		- Nếu top heap không đủ lớn, yêu cầu bộ nhớ mở rộng nó bằng hàm `sbrk`.
		- Nếu top heap không thể mở rộng được, yêu cầu bộ nhớ cấp phát một chunk bằng hàm `mmap`.
	5. Nếu tất cả các chiến lược trên đều fail, return NULL.


#### FREE STRATEGIES:
Tương ứng với chiến lược allocation trên, ta có chiến lược free như sau:

1. Nếu con trỏ là NULL, không làm gì cả.
2. Ngược lại, chuyển con trỏ về đầu chunk bằng cách trừ đi kích thước của metadata.
3. Tiến hành một số phép kiểm sanity check trên chunk, hủy bỏ nếu sanity check fail.
4. Nếu chunk phù hợp với một tcache bin, đẩy nó vào tcache bin.
5. Nếu chunk có bit M được set, trả nó về cho OS thông qua hàm `munmap`.
6. Ngược lại, chờ để lấy `heap lock` và:
	1. Nếu chunk phù hợp với một fast bin, đẩy nó vào fast bin tương ứng và kết thúc.
	2. Nếu chunk > 64 KB, tiến hành gộp các chunk trong fast bin và đẩy các chunk đã gộp vào unsorted bin.
	3. Gộp chunk với các `freed chunk` xung quanh.
	4. Nếu chunk sau khi gộp nằm ở đỉnh heap, gộp nó với top heap thay vì đẩy vào một bin.
	5. Ngược lại, lưu trữ nó trong unsorted bin. (các chunk trong unsorted bin sẽ được đẩy vào small bin hoặc large bin sau này khi gọi hàm malloc).


#### unlink(AV, P, BK, FD)
Đây là hàm dùng để remove một chunk ra khỏi bin (xảy ra khi chunk được cấp phát cho người dùng, hoặc khi chunk đó được merge với `freed chunk` xung quanh, ...):
1. Check xem **chunk size** của chunk hiện tại có bằng **prev_size** của chunk kế tiếp. Nếu không thỏa, báo lỗi "corupted size vs. prev_size".
2. Check xem `P->fd->bk == P` và `P->bk->fd == P` hay không. Nếu không thỏa, báo lỗi "corupted double-linked list".
3. Điều chỉnh lại con trỏ FD và BK của 2 chunk trước và sau nó trong bin list:
	- Set P->fd->bk = P->bk.
	- Set P->bk->fd = P->fd.


## SECURITY CHECKS 
Để giúp cho ứng dụng an toàn hơn, có một số sanity check được thực hiện trong quá trình làm việc với heap. Nếu check fail, sẽ phát sinh ra lỗi.

![sanity-check-1.png](sanity-check-1.png)

![sanity-check-2.png](sanity-check-2.png)
