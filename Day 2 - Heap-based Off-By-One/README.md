# Day 2 - Heap-based Off-By-One
1. [What is heap?](#what-is-heap)
2. [Heap rules](#heap-rules)
3. [Basic chunk allocation](#basic-chunk-allocation)
4. [Chunk structure](#chunk-structure)
5. [Bins](#bins)
6. [Allocation and free strategies](#allocation-and-free-strategies)
7. [Security checks](#security-checks)

## OFF-BY-ONE - WHAT?
Buffer-overflow là lỗi xảy khi người dùng ghi vào một biến buffer số lượng byte nhiều hơn kích thước của buffer. Buffer over flow gây ra nhiều lỗi nghiêm trọng khi người dùng có thể overwrite vào các vị trí quan trọng như return address (đối với Stack overflow) hay overwrite vào chunk nằm sau chunk hiện tại (đối với Heap overflow). 

Off-by-one là một dạng lỗi buffer-overflow trong đó số byte vượt sức chứa của buffer chỉ là 1 byte. Tuy chỉ overflow 1 byte nhưng cũng đã đủ khiến chương trình trở nên exploitable.

## OFF-BY-ONE - WHEN?
Lỗi off-by-one kín đáo hơn và khó phát hiện hơn so với buf-overflow thông thường.
Off-by-one thường xảy ra trong các tình huống sau:
1. Sử dụng vòng lặp với biến lặp được set không chính xác.
	VD: Thay vì phải dùng:
```c
for (i = 0; i < 10; i++) {
	...
}
```
	thì lại dùng sai thành:
```c
for (i = 0; i <=10; i++) {
	...
}
```
2. Sử dụng các hàm read input không đúng cách.
	Giả sử `char buf[40]; char buf2[60]; char buf3[41]`. Các đoạn code sau đây sẽ gây ra lỗi off-by-one:
```c
scanf("%40s", buf);
```
> Câu lệnh trên sẽ lây 40 bytes từ input ghi vào buf, nhưng nó lại thêm 1 NULL byte vào cuối của buf.
```c
read(stdin, buf, 40);
```
> Câu lệnh trên sẽ lấy 40 bytes từ input ghi vào buf, nhưng nó sẽ không thêm NULL byte vào cuối buf, gây ra lỗi **information leak**.
```c
strncpy(buf, buf2, 40);
```
> Tương tự read() phía trên, không đặt NULL byte vào cuối dẫn đến **information leak**.
```c
memcpy(buf, buf2, 40);
```
> Tương tự strncpy() -> **information leak**.
```c
strcat(buf, buf3);
```
> strcat() thêm NULL byte vào cuối buf.
```c
strncat(buf, buf2, 40);
```
> Tương tự strcat(), strncat() đặt NULL byte vào cuối buf.