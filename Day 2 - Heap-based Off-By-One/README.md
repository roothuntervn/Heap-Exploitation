# Day 2 - Heap-based Off-By-One
1. [Off-By-One?](#off\-by\-one)
2. [Vulnerable code](#vulnerable-code)
3. [Heap-based off-by-one](#heap\-based-off\-by\-one)
4. [Example 1: Asis CTF 2016 b00ks](#example-1\:-asis-ctf-2016-b00ks)


## OFF-BY-ONE?
Buffer-overflow là lỗi xảy khi người dùng ghi vào một biến buffer số lượng byte nhiều hơn kích thước của buffer. Buffer over flow gây ra nhiều lỗi nghiêm trọng khi người dùng có thể overwrite vào các vị trí quan trọng như return address (đối với Stack overflow) hay overwrite vào chunk nằm sau chunk hiện tại (đối với Heap overflow). 

Off-by-one là một dạng lỗi buffer-overflow trong đó số byte vượt sức chứa của buffer chỉ là 1 byte. Tuy chỉ overflow 1 byte nhưng cũng đã đủ khiến chương trình trở nên exploitable.


## VULNERABLE CODE
Lỗi off-by-one kín đáo hơn và khó phát hiện hơn so với buf-overflow thông thường.
Off-by-one thường xảy ra trong các tình huống sau:
1. Sử dụng vòng lặp với biến lặp được set không chính xác.
	- VD: Thay vì phải dùng:
	`for (i = 0; i < 10; i++) { ... }`
	thì lại dùng sai thành:
	`for (i = 0; i <=10; i++) { ... }`

2. Sử dụng các hàm read input không đúng cách.
	- Giả sử `char buf[40]; char buf2[60]; char buf3[41]`. Các đoạn code sau đây sẽ gây ra lỗi off-by-one:

`scanf("%40s", buf);`
> Câu lệnh trên sẽ lây 40 bytes từ input ghi vào buf, nhưng nó lại thêm 1 NULL byte vào cuối của buf.

`read(stdin, buf, 40);`
> Câu lệnh trên sẽ lấy 40 bytes từ input ghi vào buf, nhưng nó sẽ không thêm NULL byte vào cuối buf, gây ra lỗi **information leak**.

`strncpy(buf, buf2, 40);`
> Tương tự read() phía trên, không đặt NULL byte vào cuối dẫn đến **information leak**.

`memcpy(buf, buf2, 40);`
> Tương tự strncpy() -> **information leak**.

`strcat(buf, buf3);`
> strcat() thêm NULL byte vào cuối buf.

`strncat(buf, buf2, 40);`
> Tương tự strcat(), strncat() đặt NULL byte vào cuối buf.


## HEAP-BASED OFF-BY-ONE
Lỗi off-by-one nếu xảy ra đối với Heap có thể dẫn đến các tình huống sau:
1. Sử dụng off-by-one để thay đổi **chunk-size** của chunk kế tiếp, gây chồng lấp các chunk, có thể dẫn đến **information leak** hoặc overwrite lên chunk khác.
2. Byte NULL khi overflow vào **chunk-size** sẽ set bit **P** (prev_in_use) thành 0, do đó chunk hiện tại sẽ được coi như `free chunk`. Nếu chunk kế tiếp được `free`, chunk hiện tại sẽ bị gộp và unlink -> **unlink attack**. Hoặc lúc này bit **P** = 0, nên **prev_size** được sử dụng, ta có thể set **prev_size** tùy ý dẫn đến chồng lấp chunk.

Ví dụ code sau:
```c
int main(void)
{
    char buffer[40]="";
    void *chunk1;
    chunk1=malloc(24);
    puts("Get Input");
    gets(buffer);
    if(strlen(buffer)==24)
    {
        strcpy(chunk1,buffer);
    }
    return 0;

}
```
Code trên nếu không để ý kỹ sẽ không phát hiện lỗi off-by-one. Hàm strlen() tính độ dài của buffer sẽ không tính NULL byte ở cuối. Nhưng hàm strcpy() sẽ copy cả NULL byte vào chunk1 gây ra off-by-one bug.
Trạng thái heap trước khi strcpy():
```bash
0x602000:   0x0000000000000000  0x0000000000000021 <=== chunk1
0x602010:   0x0000000000000000  0x0000000000000000
0x602020:   0x0000000000000000  0x0000000000000411 <=== next chunk
```
Nếu ta nhập vào 24 kí tự 'A', kết quả là:
```bash
0x602000:   0x0000000000000000  0x0000000000000021
0x602010:   0x4141414141414141  0x4141414141414141
0x602020:   0x4141414141414141  0x0000000000000400
```
NULL byte đã overwrite vào prev_size làm bit **P** được set thành 0.


## EXAMPLE 1: ASIS CTF 2016 b00ks
